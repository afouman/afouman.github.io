<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive DNA Strands Side-by-Side</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: monospace;
      padding: 20px;
      margin: 0;
      display: flex;
    }

    h1 {
      margin-bottom: 10px;
    }

    /* Sidebar */
    #sidebar {
      width: 200px;
      border-right: 2px solid #444;
      padding-right: 10px;
      margin-right: 20px;
      display: flex;
      flex-direction: column;
    }

    #saved-list {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .saved-item {
      background-color: #222;
      border: 1px solid #555;
      padding: 8px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
    }

    .delete-btn {
        position: absolute;
        top: 2px;
        right: 4px;
        background-color: transparent;
        border: none;
        color: #ff6a6a;
        font-size: 14px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s;
    }

    .delete-btn:hover {
        opacity: 1;
    }

    /* Main container */
    #main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 100vh;
    }

    /* New box under button */
    #extra-box {
      flex-grow: 1;
      margin-top: 10px;
      background-color: #222;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      position: relative;
      height: 100%;
      min-height: 300px;
    }
    #extra-box canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    #infoBox {
      position: absolute;
      top: 20px;
      left: 20px;
      max-width: 400px;
      max-height: 70vh;
      overflow-y: auto;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      font-family: monospace;
      font-size: 14px;
      border: 1px solid #888;
      border-radius: 4px;
      display: none;
      z-index: 10;
      white-space: pre-wrap;
    }

    #controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 10;
        background-color: rgba(0, 0, 0, 0.75);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-family: monospace;
    }

    /* Modal overlay and content */
    #modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }

    #modal-content {
      background-color: #111;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 20px;
      max-width: 95%;
      overflow: auto;
      max-height: 90vh;
      position: relative;
    }

    #close-btn,
    #save-btn,
    #remove-btn {
      background: #444;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      padding: 6px 14px;
      margin: 10px;
    }

    #remove-btn {
        background: #ff6a6a;
    }

    #open-modal-btn {
      background-color: #444;
      color: white;
      border: none;
      font-size: 18px;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 10px;
      align-self: flex-start;
    }

    #main-layout {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      margin-left: 40px;
      width: fit-content;
    }

    #dna-container {
      position: relative;
      width: fit-content;
      height: 300px;
      margin: 0;
    }

    .strand-row {
      position: absolute;
      display: flex;
      gap: 20px;
    }

    .nucleotide {
      width: 40px;
      height: 40px;
      border-radius: 14px;
      font-weight: bold;
      font-size: 28px;
      line-height: 40px;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 0 5px #000;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.3s;
    }

    .A { background-color: #90ee90; color: black; }
    .T { background-color: #da70d6; color: black; }
    .C { background-color: #ff6a6a; color: black; }
    .G { background-color: #6495ed; color: black; }

    .vertical-connector {
      position: absolute;
      width: 4px;
      background-color: #f4d17a;
      border-radius: 2px;
      z-index: 1;
    }

    #legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      color: white;
      font-size: 16px;
      margin-bottom: 20px;
    }

    #legend div {
      display: flex;
      align-items: center;
      white-space: nowrap;
    }
    #saved-list {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #legend span.color-box {
      width: 20px;
      height: 20px;
      border-radius: 5px;
      margin-right: 10px;
      display: inline-block;
    }

    .btn-row {
      text-align: right;
    }
  </style>
</head>
<body>

<div id="sidebar">
  <h2>Saved DNA</h2>
  <div id="saved-list"></div>
</div>

<div id="main">
  <h1>Interactive DNA Strands Side-by-Side</h1>
  <button id="open-modal-btn">New DNA</button>
  <div id="extra-box">
    <div id="infoBox"></div>
    <div id="controls">
        <label for="dot-speed-slider">Dot Vibration Speed:</label>
        <input type="range" id="dot-speed-slider" min="0" max="1" step="0.001" value="0.005">
    </div>
  </div>

  <div id="modal-overlay">
    <div id="modal-content">
      <div class="btn-row">
        <div style="text-align: center; margin-bottom: 0px;">
          <input type="text" id="dna-name-input" placeholder="Enter DNA Name" style="font-size: 18px; padding: 6px 10px; border-radius: 5px; border: 1px solid #ccc;">
        </div>
        <button id="save-btn" style="display: none;">Save</button>
        <button id="remove-btn" style="display: none;">Remove</button>
        <button id="close-btn">Close</button>
      </div>
      <div id="main-layout">
        <div id="dna-container"></div>

        <div id="legend">
          <div><span class="color-box" style="background-color:#90ee90"></span> Adenine (A)</div>
          <div><span class="color-box" style="background-color:#da70d6"></span> Thymine (T)</div>
          <div><span class="color-box" style="background-color:#ff6a6a"></span> Cytosine (C)</div>
          <div><span class="color-box" style="background-color:#6495ed"></span> Guanine (G)</div>
          <div><span class="color-box" style="background-color:#f4d17a"></span> Sugar-Phosphate Backbone</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script>
    let threeJSInitialized = false;
    let uranus, ring, ringParticles, flashingStars, controls, camera, renderer;
    let dotData = [];
    let continents = [];
    const extraBox = document.getElementById('extra-box');
    const infoBox = document.getElementById('infoBox');
    let currentDotForDNA = null;
    let tempNewDot = null;
    let selectableObjects = [];

    // Dot vibration speed and radius
    let dotVibrationSpeed = 0.005;
    const dotRadius = 0.06;
    let planetRadius;
    const dotCreationCooldown = 30000;

    function initPlanetVisualization() {
      if (threeJSInitialized) return;

      const scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(60, extraBox.clientWidth / extraBox.clientHeight, 0.1, 1000);
      camera.position.set(0, 5, 21);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(extraBox.clientWidth, extraBox.clientHeight);
      extraBox.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 50;

      scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);

      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('uranus1.jpg', function(texture) {
        planetRadius = 3;

        const geometry = new THREE.SphereGeometry(planetRadius, 128, 128);
        const material = new THREE.MeshPhongMaterial({ map: texture });
        uranus = new THREE.Mesh(geometry, material);
        uranus.rotation.x = 0.5;
        scene.add(uranus);

        selectableObjects = [uranus];

        function createRandomContinent(centerLat, centerLon, radius, latSize = 15, lonSize = 15, resolution = 1) {
          const positions = [];
          const indices = [];
          const latLonCoordinates = [];

          const latSteps = Math.floor(latSize / resolution);
          const lonSteps = Math.floor(lonSize / resolution);
          const latStart = centerLat - latSize / 2;
          const lonStart = centerLon - lonSize / 2;

          const grid = [];

          for (let i = 0; i <= latSteps; i++) {
            grid[i] = [];
            for (let j = 0; j <= lonSteps; j++) {
              const dx = i - latSteps / 2;
              const dy = j - lonSteps / 2;
              const dist = Math.sqrt(dx * dx + dy * dy) / (latSteps / 2);
              const noise = Math.random() * 0.5 + 0.5;
              grid[i][j] = dist < noise ? 1 : 0;
            }
          }

          for (let i = 0; i <= latSteps; i++) {
            for (let j = 0; j <= lonSteps; j++) {
              const lat = latStart + i * resolution;
              const lon = lonStart + j * resolution;

              const phi = THREE.MathUtils.degToRad(90 - lat);
              const theta = THREE.MathUtils.degToRad(lon);

              const isLand = grid[i][j] === 1;
              const r = isLand ? radius + 0.015 : radius;

              const x = r * Math.sin(phi) * Math.cos(theta);
              const y = r * Math.cos(phi);
              const z = r * Math.sin(phi) * Math.sin(theta);

              positions.push(x, y, z);
              latLonCoordinates.push({ lat, lon, isLand });
            }
          }

          const vertsPerRow = lonSteps + 1;
          for (let i = 0; i < latSteps; i++) {
            for (let j = 0; j < lonSteps; j++) {
              const a = i * vertsPerRow + j;
              const b = a + vertsPerRow;
              const c = a + 1;
              const d = b + 1;

              if (grid[i][j] && grid[i + 1][j] && grid[i][j + 1]) {
                indices.push(a, b, c);
              }
              if (grid[i + 1][j] && grid[i + 1][j + 1] && grid[i][j + 1]) {
                indices.push(b, d, c);
              }
            }
          }

          const continentGeometry = new THREE.BufferGeometry();
          continentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
          continentGeometry.setIndex(indices);
          continentGeometry.computeVertexNormals();

          const continentMaterial = new THREE.MeshPhongMaterial({
            color: 0x2e8b57,
            side: THREE.DoubleSide,
            flatShading: true,
            transparent: true,
            opacity: 0.9
          });

          const continentMesh = new THREE.Mesh(continentGeometry, continentMaterial);
          uranus.add(continentMesh);

          return { latLonCoordinates, mesh: continentMesh };
        }

        const baseLatSize = 15;
        const baseLonSize = 15;

        continents.push(createRandomContinent(
          THREE.MathUtils.randFloat(-45, 45),
          THREE.MathUtils.randFloat(-180, 180),
          planetRadius,
          baseLatSize,
          baseLonSize,
          1
        ));

        for (let i = 0; i < 5; i++) {
          const scale = THREE.MathUtils.randFloat(1, 3);
          continents.push(createRandomContinent(
            THREE.MathUtils.randFloat(-60, 60),
            THREE.MathUtils.randFloat(-180, 180),
            planetRadius,
            baseLatSize * scale,
            baseLonSize * scale,
            1
          ));
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        function createDot(point, insideContinent, continentIndex) {
            let dotColor;
            if (insideContinent) {
                dotColor = 0xff0000;
            } else {
                dotColor = 0x8B4513;
            }

            const dotGeometry = new THREE.SphereGeometry(dotRadius, 16, 16);
            const dotMaterial = new THREE.MeshBasicMaterial({ color: dotColor });
            const newDot = new THREE.Mesh(dotGeometry, dotMaterial);
            newDot.position.copy(point);
            uranus.add(newDot);

            const newDotData = {
                id: THREE.MathUtils.generateUUID(),
                mesh: newDot,
                position: point.clone(),
                insideContinent,
                continentIndex,
                cooldownUntil: 0,
                dnaData: null
            };

            newDot.userData.dotId = newDotData.id;

            dotData.push(newDotData);
            selectableObjects.push(newDot);

            return newDotData;
        }

        extraBox.addEventListener("mousemove", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(selectableObjects);

          if (intersects.length > 0) {
              const object = intersects[0].object;
              if (object !== uranus && object !== intersectedObject) {
                  intersectedObject = object;
                  const dotId = object.userData.dotId;
                  const dot = dotData.find(d => d.id === dotId);
                  if (dot) {
                      const dnaInfo = dot.dnaData ? 'DNA Defined:\n' + dot.dnaData.map(bp => bp.join('')).join('-') : 'No DNA defined.';
                      infoBox.innerText = `Dot ID: ${dotId.substring(0,8)}...\nInside Continent: ${dot.insideContinent}\n` + dnaInfo;
                      infoBox.style.display = "block";
                  }
              }
          } else {
              intersectedObject = null;
              infoBox.style.display = "none";
          }
        });

        extraBox.addEventListener("click", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(selectableObjects.filter(obj => obj !== uranus));

          if (intersects.length > 0) {
            const dotMesh = intersects[0].object;
            const dotId = dotMesh.userData.dotId;
            const dot = dotData.find(d => d.id === dotId);
            const savedDNAEntry = savedDNAs.find(s => s.dotId === dotId);
            if (dot) {
                currentDotForDNA = dot.id;
                tempNewDot = null;
                if (dot.dnaData) {
                    initializeDNA(dot.dnaData);
                } else {
                    initializeDNA();
                }

                if (savedDNAEntry) {
                    document.getElementById('dna-name-input').value = savedDNAEntry.name;
                } else {
                    document.getElementById('dna-name-input').value = '';
                }

                document.getElementById('save-btn').style.display = 'none';
                document.getElementById('remove-btn').style.display = 'inline-block';
                modal.style.display = 'flex';
                requestAnimationFrame(() => {
                    positionNucleotides();
                    drawConnectors();
                });
            }
          }
        });

        extraBox.addEventListener("dblclick", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;

          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(uranus);

          if (intersects.length > 0) {
            const point = intersects[0].point;
            const localPoint = uranus.worldToLocal(point.clone());
            const r = localPoint.length();
            const lat = 90 - THREE.MathUtils.radToDeg(Math.acos(localPoint.y / r));
            const lon = THREE.MathUtils.radToDeg(Math.atan2(localPoint.z, localPoint.x));

            let insideContinent = false;
            let continentIndex = null;
            for (let i = 0; i < continents.length; i++) {
              const continent = continents[i];
              const lats = continent.latLonCoordinates.map(p => p.lat);
              const lons = continent.latLonCoordinates.map(p => p.lon);
              const minLat = Math.min(...lats);
              const maxLat = Math.max(...lats);
              const minLon = Math.min(...lons);
              const maxLon = Math.max(...lons);

              if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                let minDist = Infinity;
                let closestPoint = null;
                for (const p of continent.latLonCoordinates) {
                  const dLat = p.lat - lat;
                  const dLon = p.lon - lon;
                  const dist = dLat * dLat + dLon * dLon;
                  if (dist < minDist) {
                    minDist = dist;
                    closestPoint = p;
                  }
                }
                if (closestPoint && closestPoint.isLand) {
                  insideContinent = true;
                  continentIndex = i;
                  break;
                }
              }
            }
            const newDotData = createDot(localPoint, insideContinent, continentIndex);
            tempNewDot = newDotData;
            currentDotForDNA = newDotData.id;

            infoBox.innerText = `Dot added at\nLat: ${lat.toFixed(2)}°, Lon: ${lon.toFixed(2)}°\nInside continent: ${insideContinent}` +
              (insideContinent ? ` (Index: ${continentIndex})` : '');
            infoBox.style.display = "block";

            initializeDNA();
            document.getElementById('dna-name-input').value = '';
            document.getElementById('save-btn').style.display = 'inline-block';
            document.getElementById('remove-btn').style.display = 'none';
            modal.style.display = 'flex';
             requestAnimationFrame(() => {
                positionNucleotides();
                drawConnectors();
            });
          } else {
            infoBox.style.display = "none";
          }
        });

        const ringGeometry = new THREE.RingGeometry(4, 6, 128);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0xaaaaaa,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.4
        });
        ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2 + 0.5;
        ring.rotation.z = 0.5;
        scene.add(ring);

        const ringParticleCount = 35000;
        const ringParticlePositions = [];
        const ringParticleColors = [];

        const colors = [
          new THREE.Color(0xff0000),
          new THREE.Color(0xffff00),
          new THREE.Color(0x00ff00),
          new THREE.Color(0x8b4513)
        ];

        function getGradientColor(t) {
          const segment = t * (colors.length);
          const index1 = Math.floor(segment) % colors.length;
          const index2 = (index1 + 1) % colors.length;
          const localT = segment - Math.floor(segment);
          return colors[index1].clone().lerp(colors[index2], localT);
        }

        for (let i = 0; i < ringParticleCount; i++) {
          const angle = (i / ringParticleCount) * 2 * Math.PI;
          const radius = THREE.MathUtils.lerp(4.1, 5.9, Math.random());
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          const z = (Math.random() - 0.5) * 0.05;

          ringParticlePositions.push(x, y, z);
          const color = getGradientColor(i / ringParticleCount);
          ringParticleColors.push(color.r, color.g, color.b);
        }

        const ringParticleGeometry = new THREE.BufferGeometry();
        ringParticleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ringParticlePositions, 3));
        ringParticleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(ringParticleColors, 3));

        const starTexture = (() => {
          const size = 64;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
          gradient.addColorStop(0, 'rgba(255,255,255,1)');
          gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
          gradient.addColorStop(0.4, 'rgba(255,255,255,0.4)');
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, size, size);
          return new THREE.CanvasTexture(canvas);
        })();

        const ringParticleMaterial = new THREE.PointsMaterial({
          size: 0.15,
          map: starTexture,
          vertexColors: true,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending,
          opacity: 0.25,
          depthWrite: false,
        });

        ringParticles = new THREE.Points(ringParticleGeometry, ringParticleMaterial);
        ringParticles.rotation.x = Math.PI / 2 + 0.5;
        ringParticles.rotation.z = 0.5;
        scene.add(ringParticles);

        const starCount = 20000;
        const starVertices = [];
        const flashVertices = [];

        for (let i = 0; i < starCount; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          if (Math.random() < 0.1) {
            flashVertices.push(x, y, z);
          } else {
            starVertices.push(x, y, z);
          }
        }

        const starsGeometry = new THREE.BufferGeometry();
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 1.8,
          map: starTexture,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        const flashingGeometry = new THREE.BufferGeometry();
        flashingGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flashVertices, 3));
        const flashingMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 4.5,
          map: starTexture,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending,
          opacity: 1
        });
        flashingStars = new THREE.Points(flashingGeometry, flashingMaterial);
        scene.add(flashingStars);

        let time = 0;

        function isPointInContinent(point, continent) {
            const tempVec = new THREE.Vector3().copy(point).normalize();
            const lat = 90 - THREE.MathUtils.radToDeg(Math.acos(tempVec.y));
            const lon = THREE.MathUtils.radToDeg(Math.atan2(tempVec.z, tempVec.x));

            const lats = continent.latLonCoordinates.map(p => p.lat);
            const lons = continent.latLonCoordinates.map(p => p.lon);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);

            if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                let minDist = Infinity;
                let closestPoint = null;
                for (const p of continent.latLonCoordinates) {
                    const dLat = p.lat - lat;
                    const dLon = p.lon - lon;
                    const dist = dLat * dLat + dLon * dLon;
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = p;
                    }
                }
                return closestPoint && closestPoint.isLand;
            }
            return false;
        }

        function animate() {
          requestAnimationFrame(animate);
          time += 0.02;

          if (uranus) uranus.rotation.y += 0.001;
          if (ring) ring.rotation.z += 0.0005;
          if (ringParticles) ringParticles.rotation.z += 0.0007;

          if (flashingMaterial) flashingMaterial.opacity = 0.5 + 0.5 * Math.sin(time * 2);

          dotData.forEach(dot => {
              let newPosition = dot.mesh.position.clone();
              const vibration = new THREE.Vector3(
                  (Math.random() - 0.5),
                  (Math.random() - 0.5),
                  (Math.random() - 0.5)
              ).normalize().multiplyScalar(dotVibrationSpeed);

              newPosition.add(vibration);

              newPosition.normalize().multiplyScalar(planetRadius + 0.02);

              if (dot.insideContinent) {
                  if (Math.random() < 0.99) {
                      const continent = continents[dot.continentIndex];
                      if (isPointInContinent(newPosition, continent)) {
                          dot.mesh.position.copy(newPosition);
                      }
                  } else {
                      dot.mesh.position.copy(newPosition);
                  }
              } else {
                  dot.mesh.position.copy(newPosition);
              }
          });

          const now = Date.now();
          const twoRadiiSquared = (dotRadius * 2) * (dotRadius * 2);

          for (let i = 0; i < dotData.length; i++) {
              for (let j = i + 1; j < dotData.length; j++) {
                  const dotA = dotData[i];
                  const dotB = dotData[j];

                  const distanceSquared = dotA.mesh.position.distanceToSquared(dotB.mesh.position);

                  if (distanceSquared < twoRadiiSquared) {
                      if (dotA.cooldownUntil < now && dotB.cooldownUntil < now) {
                          dotA.cooldownUntil = now + dotCreationCooldown;
                          dotB.cooldownUntil = now + dotCreationCooldown;

                          let newColor;
                          if (dotA.insideContinent && dotB.insideContinent) {
                              newColor = 0xff8080;
                          } else if (!dotA.insideContinent && !dotB.insideContinent) {
                              newColor = 0xd2b48c;
                          } else {
                              newColor = 0xffd700;
                          }

                          const newPosition = dotA.mesh.position.clone().add(dotB.mesh.position).divideScalar(2);
                          const newDotData = createDot(newPosition, dotA.insideContinent || dotB.insideContinent, dotA.continentIndex || dotB.continentIndex);
                          newDotData.mesh.material.color.set(newColor);
                          newDotData.cooldownUntil = now + dotCreationCooldown;
                      }
                  }
              }
          }
          if (controls) controls.update();
          if (renderer) renderer.render(scene, camera);
        }

        animate();
      });

      threeJSInitialized = true;
    }

    const speedSlider = document.getElementById('dot-speed-slider');
    if (speedSlider) {
        dotVibrationSpeed = parseFloat(speedSlider.value);

        speedSlider.addEventListener('input', (event) => {
            dotVibrationSpeed = parseFloat(event.target.value);
        });
    }

    const container = document.getElementById('dna-container');
    const basePairsCount = 30;
    const bases = ['A', 'T', 'C', 'G'];
    const complement = { 'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C' };
    const spacingX = 60;
    const twists = 3;

    const topNucleotides = [];
    const bottomNucleotides = [];

    let currentDNA = [];
    let loadedIndex = null;

    const topRow = document.createElement('div');
    topRow.className = 'strand-row';
    container.appendChild(topRow);

    const bottomRow = document.createElement('div');
    bottomRow.className = 'strand-row';
    container.appendChild(bottomRow);

    topRow.style.top = '100px';
    topRow.style.left = '20px';
    bottomRow.style.top = '250px';
    bottomRow.style.left = '20px';

    function initializeDNA(dnaData = null) {
        topRow.innerHTML = '';
        bottomRow.innerHTML = '';
        topNucleotides.length = 0;
        bottomNucleotides.length = 0;

        for (let i = 0; i < basePairsCount; i++) {
            const base = dnaData ? dnaData[i][0] : bases[Math.floor(Math.random() * 4)];
            const comp = complement[base];

            const topNuc = document.createElement('div');
            topNuc.className = `nucleotide ${base}`;
            topNuc.textContent = base;
            topNuc.dataset.base = base;
            topRow.appendChild(topNuc);
            topNucleotides.push(topNuc);

            const bottomNuc = document.createElement('div');
            bottomNuc.className = `nucleotide ${comp}`;
            bottomNuc.textContent = comp;
            bottomNuc.dataset.base = comp;
            bottomRow.appendChild(bottomNuc);
            bottomNucleotides.push(bottomNuc);

            topNuc.addEventListener('click', () => {
                let currentBase = topNuc.dataset.base;
                let newBase = bases[(bases.indexOf(currentBase) + 1) % 4];
                let newComp = complement[newBase];

                topNuc.dataset.base = newBase;
                topNuc.textContent = newBase;
                topNuc.className = 'nucleotide ' + newBase;

                bottomNuc.dataset.base = newComp;
                bottomNuc.textContent = newComp;
                bottomNuc.className = 'nucleotide ' + newComp;

                drawConnectors();
            });
        }

        positionNucleotides();
        drawConnectors();
    }

    function positionNucleotides() {
        for (let i = 0; i < basePairsCount; i++) {
            const x = i * spacingX;
            const yOffsetTop = 40 * Math.sin((i / basePairsCount) * twists * 2 * Math.PI);
            const yOffsetBottom = 40 * Math.sin((i / basePairsCount) * twists * 2 * Math.PI + Math.PI);

            topNucleotides[i].style.position = 'absolute';
            topNucleotides[i].style.left = `${x}px`;
            topNucleotides[i].style.top = `${yOffsetTop}px`;

            bottomNucleotides[i].style.position = 'absolute';
            bottomNucleotides[i].style.left = `${x}px`;
            bottomNucleotides[i].style.top = `${yOffsetBottom}px`;
        }
    }

    function drawConnectors() {
        const oldConnectors = container.querySelectorAll('.vertical-connector');
        oldConnectors.forEach(line => line.remove());

        for (let i = 0; i < basePairsCount; i++) {
            const topNuc = topNucleotides[i];
            const bottomNuc = bottomNucleotides[i];

            const topRect = topNuc.getBoundingClientRect();
            const bottomRect = bottomNuc.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const x = topRect.left - containerRect.left + topRect.width / 2;
            const yStart = topRect.top - containerRect.top + topRect.height;
            const yEnd = bottomRect.top - containerRect.top;

            const height = yEnd - yStart;

            const line = document.createElement('div');
            line.className = 'vertical-connector';
            line.style.left = `${x}px`;
            line.style.top = `${yStart}px`;
            line.style.height = `${height}px`;

            container.appendChild(line);
        }
    }

    function getCurrentDNA() {
        return topNucleotides.map((top, i) => [top.dataset.base, bottomNucleotides[i].dataset.base]);
    }

    const savedList = document.getElementById('saved-list');
    const modal = document.getElementById('modal-overlay');
    const openBtn = document.getElementById('open-modal-btn');
    const closeBtn = document.getElementById('close-btn');
    const saveBtn = document.getElementById('save-btn');
    const removeBtn = document.getElementById('remove-btn');

    const savedDNAs = [];
    let unnamedCounter = 1;
    let unnamedPlanetCounter = 1;

    openBtn.addEventListener('click', () => {
        currentDotForDNA = null;
        loadedIndex = null;
        tempNewDot = null;
        initializeDNA();
        document.getElementById('dna-name-input').value = '';
        saveBtn.style.display = 'inline-block';
        removeBtn.style.display = 'none';
        modal.style.display = 'flex';
        requestAnimationFrame(() => {
            positionNucleotides();
            drawConnectors();
        });
    });

    closeBtn.addEventListener('click', () => {
        if (tempNewDot) {
            const dotToRemoveMesh = tempNewDot.mesh;
            uranus.remove(dotToRemoveMesh);

            dotData = dotData.filter(dot => dot.mesh !== dotToRemoveMesh);
            selectableObjects = selectableObjects.filter(obj => obj !== dotToRemoveMesh);
        }
        currentDotForDNA = null;
        tempNewDot = null;
        loadedIndex = null;
        modal.style.display = 'none';
    });

    saveBtn.addEventListener('click', () => {
        const nameField = document.getElementById('dna-name-input');
        let name = nameField.value.trim();
        const dna = getCurrentDNA();

        let dotId = null;
        if (tempNewDot) {
            tempNewDot.dnaData = dna;
            dotId = tempNewDot.id;
        } else if (currentDotForDNA !== null) {
            const dotToUpdate = dotData.find(d => d.id === currentDotForDNA);
            if (dotToUpdate) {
                dotToUpdate.dnaData = dna;
                dotId = dotToUpdate.id;
            }
        }

        if (!name) {
          if (dotId) {
            name = `Planet DNA ${unnamedPlanetCounter++}`;
          } else {
            name = `Undefined DNA ${unnamedCounter++}`;
          }
        }

        if (loadedIndex !== null) {
            savedDNAs[loadedIndex] = { name, data: dna, dotId };
        } else {
            savedDNAs.push({ name, data: dna, dotId });
        }

        updateSavedList();
        currentDotForDNA = null;
        loadedIndex = null;
        tempNewDot = null;
        modal.style.display = 'none';
        document.getElementById('dna-name-input').value = '';
    });

    removeBtn.addEventListener('click', () => {
        if (currentDotForDNA !== null) {
            const dotToRemove = dotData.find(d => d.id === currentDotForDNA);
            if (dotToRemove) {
                uranus.remove(dotToRemove.mesh);
                dotData = dotData.filter(d => d.id !== currentDotForDNA);
                selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== currentDotForDNA);
            }

            const savedIndex = savedDNAs.findIndex(s => s.dotId === currentDotForDNA);
            if (savedIndex !== -1) {
                savedDNAs.splice(savedIndex, 1);
            }
        }
        currentDotForDNA = null;
        updateSavedList();
        modal.style.display = 'none';
    });

    function addToSavedList(index) {
        const dnaObj = savedDNAs[index];
        const item = document.createElement('div');
        item.className = 'saved-item';
        item.dataset.index = index;

        const nameSpan = document.createElement('span');
        nameSpan.textContent = dnaObj.name;
        item.appendChild(nameSpan);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'x';
        item.appendChild(deleteBtn);

        let clickTimer = null;
        let dblClicked = false;

        nameSpan.addEventListener('dblclick', (event) => {
            event.stopPropagation();
            dblClicked = true;
            clearTimeout(clickTimer);

            const input = document.createElement('input');
            input.type = 'text';
            input.value = dnaObj.name;
            input.style.width = 'calc(100% - 20px)';
            input.style.border = 'none';
            input.style.background = '#333';
            input.style.color = 'white';
            input.style.fontFamily = 'monospace';

            item.replaceChild(input, nameSpan);
            input.focus();
            input.select();

            const saveName = () => {
                const newName = input.value.trim();
                savedDNAs[index].name = newName || `Undefined DNA ${unnamedCounter++}`;
                nameSpan.textContent = savedDNAs[index].name;
                item.replaceChild(nameSpan, input);
            };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveName();
                    input.blur();
                } else if (e.key === 'Escape') {
                    nameSpan.textContent = savedDNAs[index].name;
                    item.replaceChild(nameSpan, input);
                    input.blur();
                }
            });

            input.addEventListener('blur', saveName);
        });

        nameSpan.addEventListener('click', () => {
            dblClicked = false;
            clickTimer = setTimeout(() => {
                if (!dblClicked) {
                    currentDotForDNA = null;
                    tempNewDot = null;
                    loadedIndex = index;
                    initializeDNA(savedDNAs[index].data);
                    document.getElementById('dna-name-input').value = savedDNAs[index].name;
                    saveBtn.style.display = 'inline-block';
                    removeBtn.style.display = 'none';
                    modal.style.display = 'flex';
                    requestAnimationFrame(() => {
                        positionNucleotides();
                        drawConnectors();
                    });
                }
            }, 250);
        });

        deleteBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const dotId = savedDNAs[index].dotId;
            if (dotId) {
                const dot = dotData.find(d => d.id === dotId);
                if (dot) {
                    uranus.remove(dot.mesh);
                    dotData = dotData.filter(d => d.id !== dotId);
                    selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== dotId);
                }
            }
            savedDNAs.splice(index, 1);
            updateSavedList();
        });

        savedList.appendChild(item);
    }

    function updateSavedList() {
        savedList.innerHTML = '';
        savedDNAs.forEach((_, i) => addToSavedList(i));
    }

    window.addEventListener('resize', () => {
        positionNucleotides();
        drawConnectors();

        if (camera && renderer && controls) {
          camera.aspect = extraBox.clientWidth / extraBox.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(extraBox.clientWidth, extraBox.clientHeight);
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
      initPlanetVisualization();
    });
</script>
</body>
</html>