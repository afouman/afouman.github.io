<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Game of Life Simulator</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: monospace;
      padding: 20px;
      margin: 0;
      display: flex;
    }
    h1 {
      margin-bottom: 10px;
    }
    #sidebar {
      width: 200px;
      border-right: 2px solid #444;
      padding-right: 10px;
      margin-right: 20px;
      display: flex;
      flex-direction: column;
    }
    #saved-list {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .saved-item {
      background-color: #222;
      border: 1px solid #555;
      padding: 8px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      position: relative;
    }
    .delete-btn {
        position: absolute;
        top: 2px;
        right: 4px;
        background-color: transparent;
        border: none;
        color: #ff6a6a;
        font-size: 14px;
        cursor: pointer;
        line-height: 1;
        opacity: 0.7;
        transition: opacity 0.2s;
    }
    .delete-btn:hover {
        opacity: 1;
    }
    #main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-height: 100vh;
    }
    #extra-box {
      flex-grow: 1;
      margin-top: 10px;
      background-color: #222;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 10px;
      overflow: auto;
      position: relative;
      height: 100%;
      min-height: 300px;
    }
    #extra-box canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    #infoBox {
      position: absolute;
      top: 20px;
      left: 20px;
      max-width: 400px;
      max-height: 70vh;
      overflow-y: auto;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.75);
      color: white;
      font-family: monospace;
      font-size: 14px;
      border: 1px solid #888;
      border-radius: 4px;
      display: none;
      z-index: 10;
      white-space: pre-wrap;
    }
    #controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 10;
        background-color: rgba(0, 0, 0, 0.75);
        padding: 10px;
        border-radius: 8px;
        color: white;
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-family: monospace;
    }
    /* START: NEW LEGEND STYLES */
    #population-legend {
        position: absolute;
        bottom: 20px;
        left: 15px;
        background-color: rgba(0, 0, 0, 0.75);
        padding: 10px;
        border-radius: 8px;
        z-index: 10;
        font-size: 14px;
        border: 1px solid #666;
    }
    /* END: NEW LEGEND STYLES */
    #modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #explanation-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 1001;
      justify-content: center;
      align-items: center;
    }
    #explanation-modal-content {
      background-color: #111;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 20px;
      max-width: 600px;
      color: white;
      font-family: monospace;
      position: relative;
    }
    #explanation-modal-content h2 {
      text-align: center;
      margin-top: 0;
    }
    #explanation-modal-content ul {
      list-style-type: none;
      padding: 0;
    }
    #explanation-modal-content li {
      margin-bottom: 10px;
    }
    #close-explanation-btn {
      display: block;
      margin: 20px auto 0;
      background: #444;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      padding: 6px 14px;
    }
    #modal-content {
      background-color: #111;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 20px;
      max-width: 95%;
      max-height: 90vh;
      position: relative;
      display: flex;
      flex-direction: column;
    }
    #close-btn,
    #save-btn,
    #remove-btn {
      background: #444;
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      padding: 6px 14px;
      margin: 10px;
    }
    #remove-btn {
        background: #ff6a6a;
    }
    #explain-btn {
      background-color: #4CAF50;
      color: white;
      border: none;
      font-size: 18px;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 10px;
      align-self: flex-start;
    }
    #dna-scroll-container {
        flex-grow: 1;
        overflow: auto;
        margin-top: 10px;
    }
    #dna-container {
      position: relative;
      width: fit-content;
      height: 300px;
      margin: 0;
    }
    .strand-row {
      position: absolute;
      display: flex;
      gap: 20px;
    }
    .nucleotide {
      width: 40px;
      height: 40px;
      border-radius: 14px;
      font-weight: bold;
      font-size: 28px;
      line-height: 40px;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 0 5px #000;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background-color 0.3s;
    }
    .A { background-color: #90ee90; color: black; }
    .T { background-color: #da70d6; color: black; }
    .C { background-color: #ff6a6a; color: black; }
    .G { background-color: #6495ed; color: black; }
    .vertical-connector {
      position: absolute;
      width: 4px;
      background-color: #f4d17a;
      border-radius: 2px;
      z-index: 1;
    }
    #legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px 20px;
      color: white;
      font-size: 16px;
      margin-bottom: 20px;
    }
    #legend div {
      display: flex;
      align-items: center;
      white-space: nowrap;
    }
    #saved-list {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #legend span.color-box {
      width: 20px;
      height: 20px;
      border-radius: 5px;
      margin-right: 10px;
      display: inline-block;
    }
    .btn-row {
      text-align: right;
    }
    #index-row {
      position: absolute;
      top: 350px; /* Adjust this value to position it correctly */
      display: flex;
      z-index: 2;
    }
    .index-number {
      width: 60px;
      font-size: 12px;
      margin-left: 10px;
      text-align: center;
      color: #aaa;
    }
        .nucleotide-inline {
        display: inline-block;
        vertical-align: middle;
        width: 1.2em; /* Adjust to match font size */
        height: 1.2em;
        font-size: 1em;
        line-height: 1.2em;
        border-radius: 4px; /* Smaller border-radius */
        font-weight: bold;
        text-align: center;
        margin: 0 4px;
    }

    .nucleotide-inline.A { background-color: #90ee90; color: black; }
    .nucleotide-inline.T { background-color: #da70d6; color: black; }
    .nucleotide-inline.C { background-color: #ff6a6a; color: black; }
    .nucleotide-inline.G { background-color: #6495ed; color: black; }

  </style>
</head>
<body>
<div id="sidebar">
  <h2>Saved DNA</h2>
  <div id="saved-list"></div>
</div>
<div id="main">
  <h1>Game of Life Simulator</h1>

  <button id="explain-btn">Explain This</button>
  <div id="extra-box">
    <div id="population-legend">
        <strong>Population:</strong>
        <div id="count-inland">In-land: 0</div>
        <div id="count-offland">Off-land: 0</div>
        <div id="count-both">Both: 0</div>
    </div>
    <div id="infoBox"></div>
    <div id="controls">
        <label for="dot-speed-slider">DNA Travel Speed:</label>
        <input type="range" id="dot-speed-slider" min="0" max="1" step="0.001" value="0.005">
    </div>
  </div>
  <div id="modal-overlay">
    <div id="modal-content">
      <div class="btn-row">
        <div style="text-align: center; margin-bottom: 0px;">
          <input type="text" id="dna-name-input" placeholder="Enter DNA Name" style="font-size: 18px; padding: 6px 10px; border-radius: 5px; border: 1px solid #ccc;">
        </div>
        <button id="save-btn" style="display: none;">Save</button>
        <button id="remove-btn" style="display: none;">Remove</button>
        <button id="close-btn">Close</button>
      </div>
      <div id="legend">
        <div><span class="color-box" style="background-color:#90ee90"></span> Adenine (A)</div>
        <div><span class="color-box" style="background-color:#da70d6"></span> Thymine (T)</div>
        <div><span class="color-box" style="background-color:#ff6a6a"></span> Cytosine (C)</div>
        <div><span class="color-box" style="background-color:#6495ed"></span> Guanine (G)</div>
        <div><span class="color-box" style="background-color:#f4d17a"></span> Sugar-Phosphate Backbone</div>
      </div>
      <div id="dna-scroll-container">
        <div id="dna-container"></div>
      </div>
    </div>
  </div>
  <div id="explanation-modal-overlay">
    <div id="explanation-modal-content">
      <h2>What is Game of Life Simulator</h2>
      <p><b>PROVE THE WORLD THAT YOU CAN SUSTAIN A LIFE!!!</b></p>
      <p>
        You get to design your own DNAs on this magical planet and place them wherever you wish.
        Using the DNA Travel Speed, you set the pace for the life forms to travel through this planet and reproduce.
        As these life forms (dots) meet each other, they create a new life that is derived from their own DNAs + mutations.
        Below are the instructions on how to design your DNA and was each nucleotide pairs do.
      </p>
      <h2>DNA Strand Information</h2>
      <p>Each DNA strand has 19 base pairs, and certain pairs determine key properties of the dots. Here's a breakdown:</p>
      <ul>
        <li><b>Base pairs 0-11:</b> Determine the dot's color. The color is calculated based on the ratio of Adenine (<div class="nucleotide-inline A">A</div>), Cytosine (<div class="nucleotide-inline C">C</div>), and Guanine (<div class="nucleotide-inline G">G</div>) bases. Thymine (<div class="nucleotide-inline T">T</div>) is a wild-card, randomly becomes A, C, or G for mutation.</li>
        <li><b>Base pair 13:</b> Determines the dot's habitat. This is based on the base in the pair:
          <li></li>
          <ul>
            <li><b><div class="nucleotide-inline A">A</div>(Adenine):</b> In-land habitat</li>
            <li><b><div class="nucleotide-inline T">T</div>(Thymine):</b> Off-land habitat</li>
            <li><b><div class="nucleotide-inline C">C</div>(Cytosine):</b> Both in-land and off-land habitat</li>
            <li><b><div class="nucleotide-inline G">G</div>(Guanine):</b> Unlivable genetic mutation (habitat is 'None')</li>
          </ul>
        </li>
        <li><b>Base pairs 15-18:</b> Determine the dot's lifetime in seconds. This is calculated by converting the four bases into a 8-bit binary number and adding one. The mapping is:
          <li></li>
          <ul>
            <li><b><div class="nucleotide-inline A">A</div>(Adenine):</b> 2'b00</li>
            <li><b><div class="nucleotide-inline T">T</div>(Thymine):</b> 2'b01</li>
            <li><b><div class="nucleotide-inline C">C}</div>(Cytosine):</b> 2'b10</li>
            <li><b><div class="nucleotide-inline G">G</div>(Guanine):</b> 2'b11</li>
          </ul>
        </li>
      </ul>
      <button id="close-explanation-btn">Close</button>
    </div>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>
<script>
    let threeJSInitialized = false;
    let uranus, ring, ringParticles, flashingStars, controls, camera, renderer;
    let dotData = [];
    let continents = [];
    const extraBox = document.getElementById('extra-box');
    const infoBox = document.getElementById('infoBox');
    let currentDotForDNA = null;
    // tempNewDot now holds a data object, not a 3D mesh object, until saved.
    let tempNewDot = null;
    let selectableObjects = [];
    let savedDNAs = [];
    const savedDNAs_KEY = 'savedDNAs';
    let dotVibrationSpeed = 0.005;
    const dotRadius = 0.06;
    let planetRadius;
    const dotCreationCooldown = 30000;

    // --- START: GLOBAL UTILITY FUNCTIONS ---

    function updateLegend() {
        let countInland = 0;
        let countOffland = 0;
        let countBoth = 0;

        dotData.forEach(dot => {
            switch (dot.habitat) {
                case 'in-land':
                    countInland++;
                    break;
                case 'off-land':
                    countOffland++;
                    break;
                case 'both':
                    countBoth++;
                    break;
            }
        });

        const inlandEl = document.getElementById('count-inland');
        const offlandEl = document.getElementById('count-offland');
        const bothEl = document.getElementById('count-both');

        if (inlandEl) inlandEl.innerText = `In-land: ${countInland}`;
        if (offlandEl) offlandEl.innerText = `Off-land: ${countOffland}`;
        if (bothEl) bothEl.innerText = `Both: ${countBoth}`;
    }

    // NEW: createDot moved to global scope so it can be accessed by saveBtn
    function createDot(point, insideContinent, continentIndex, dnaData = null) {
        let dotColor = 0x8B4513; // Default color if no DNA data

        if (dnaData) {
            let aCount = 0;
            let cCount = 0;
            let gCount = 0;
            // Grab the first 12 bases and count A, C, and G
            for (let i = 0; i < Math.min(12, dnaData.length); i++) {
                const base = dnaData[i][0]; // We'll just read the first strand
                switch (base) {
                    case 'A':
                        aCount++;
                        break;
                    case 'C':
                        cCount++;
                        break;
                    case 'G':
                        gCount++;
                        break;
                    case 'T':
                        // T is a wildcard, so we'll randomly increment one of the counts
                        const randomBase = ['A', 'C', 'G'][Math.floor(Math.random() * 3)];
                        if (randomBase === 'A') aCount++;
                        else if (randomBase === 'C') cCount++;
                        else gCount++;
                        break;
                }
            }
            // Scale counts to a 0-1 range for RGB color values
            const totalCount = aCount + cCount + gCount;
            let r = 0, g = 0, b = 0;
            if (totalCount > 0) {
                r = cCount / totalCount; // C for red
                g = aCount / totalCount; // A for green
                b = gCount / totalCount; // G for blue
            }
            dotColor = new THREE.Color(r, g, b).getHex();
        } else {
            // Existing logic for inside/outside continent if no DNA data is provided
            if (insideContinent) {
                dotColor = 0xff0000;
            } else {
                dotColor = 0x8B4513;
            }
        }

        const dotGeometry = new THREE.SphereGeometry(dotRadius, 16, 16);
        const dotMaterial = new THREE.MeshBasicMaterial({ color: dotColor });
        const newDot = new THREE.Mesh(dotGeometry, dotMaterial);
        newDot.position.copy(point);

        // **Requires uranus to be initialized**
        if (uranus) uranus.add(newDot);

        const newDotData = {
            id: THREE.MathUtils.generateUUID(),
            mesh: newDot,
            position: point.clone(),
            insideContinent,
            continentIndex,
            cooldownUntil: 0,
            dnaData: dnaData,
            lifetime: null,
            creationTime: null,
            habitat: null,
        };
        newDot.userData.dotId = newDotData.id;
        dotData.push(newDotData);
        selectableObjects.push(newDot);

        updateLegend();

        return newDotData;
    }
    // --- END: GLOBAL UTILITY FUNCTIONS ---

    function initPlanetVisualization() {
      if (threeJSInitialized) return;
      const scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, extraBox.clientWidth / extraBox.clientHeight, 0.1, 1000);
      camera.position.set(0, 5, 21);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(extraBox.clientWidth, extraBox.clientHeight);
      extraBox.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 50;
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));
      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(10, 10, 10);
      scene.add(pointLight);
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load('uranus1.jpg', function(texture) {
        planetRadius = 3;
        const geometry = new THREE.SphereGeometry(planetRadius, 128, 128);
        const material = new THREE.MeshPhongMaterial({ map: texture });
        uranus = new THREE.Mesh(geometry, material);
        uranus.rotation.x = 0.5;
        scene.add(uranus);
        selectableObjects = [uranus];
        function createRandomContinent(centerLat, centerLon, radius, latSize = 15, lonSize = 15, resolution = 1) {
          const positions = [];
          const indices = [];
          const latLonCoordinates = [];
          const latSteps = Math.floor(latSize / resolution);
          const lonSteps = Math.floor(lonSize / resolution);
          const latStart = centerLat - latSize / 2;
          const lonStart = centerLon - lonSize / 2;
          const grid = [];
          for (let i = 0; i <= latSteps; i++) {
            grid[i] = [];
            for (let j = 0; j <= lonSteps; j++) {
              const dx = i - latSteps / 2;
              const dy = j - lonSteps / 2;
              const dist = Math.sqrt(dx * dx + dy * dy) / (latSteps / 2);
              const noise = Math.random() * 0.5 + 0.5;
              grid[i][j] = dist < noise ? 1 : 0;
            }
          }
          for (let i = 0; i <= latSteps; i++) {
            for (let j = 0; j <= lonSteps; j++) {
              const lat = latStart + i * resolution;
              const lon = lonStart + j * resolution;
              const phi = THREE.MathUtils.degToRad(90 - lat);
              const theta = THREE.MathUtils.degToRad(lon);
              const isLand = grid[i][j] === 1;
              const r = isLand ? radius + 0.015 : radius;
              const x = r * Math.sin(phi) * Math.cos(theta);
              const y = r * Math.cos(phi);
              const z = r * Math.sin(phi) * Math.sin(theta);
              positions.push(x, y, z);
              latLonCoordinates.push({ lat, lon, isLand });
            }
          }
          const vertsPerRow = lonSteps + 1;
          for (let i = 0; i < latSteps; i++) {
            for (let j = 0; j < lonSteps; j++) {
              const a = i * vertsPerRow + j;
              const b = a + vertsPerRow;
              const c = a + 1;
              const d = b + 1;
              if (grid[i][j] && grid[i + 1][j] && grid[i][j + 1]) {
                indices.push(a, b, c);
              }
              if (grid[i + 1][j] && grid[i + 1][j + 1] && grid[i][j + 1]) {
                indices.push(b, d, c);
              }
            }
          }
          const continentGeometry = new THREE.BufferGeometry();
          continentGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
          continentGeometry.setIndex(new THREE.Uint32BufferAttribute(indices, 1));
          continentGeometry.computeVertexNormals();
          const continentMaterial = new THREE.MeshPhongMaterial({
            color: 0x2e8b57,
            side: THREE.DoubleSide,
            flatShading: true,
            transparent: true,
            opacity: 0.9
          });
          const continentMesh = new THREE.Mesh(continentGeometry, continentMaterial);
          uranus.add(continentMesh);
          return { latLonCoordinates, mesh: continentMesh };
        }
        const baseLatSize = 15;
        const baseLonSize = 15;
        continents.push(createRandomContinent(
          THREE.MathUtils.randFloat(-45, 45),
          THREE.MathUtils.randFloat(-180, 180),
          planetRadius,
          baseLatSize,
          baseLonSize,
          1
        ));
        for (let i = 0; i < 5; i++) {
          const scale = THREE.MathUtils.randFloat(1, 3);
          continents.push(createRandomContinent(
            THREE.MathUtils.randFloat(-60, 60),
            THREE.MathUtils.randFloat(-180, 180),
            planetRadius,
            baseLatSize * scale,
            baseLonSize * scale,
            1
          ));
        }
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let intersectedObject = null;

        // **createDot definition removed from here**

        extraBox.addEventListener("mousemove", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(selectableObjects);
          if (intersects.length > 0) {
              const object = intersects[0].object;
              if (object !== uranus && object !== intersectedObject) {
                  intersectedObject = object;
                  const dotId = object.userData.dotId;
                  const dot = dotData.find(d => d.id === dotId);
                  if (dot) {
                      const dnaInfo = dot.dnaData ? 'DNA Defined:\n' + dot.dnaData.map(bp => bp.join('')).join('-') : 'No DNA defined.';
                      let timerInfo = '';
                      if (dot.lifetime !== null) {
                          const elapsed = (Date.now() - dot.creationTime) / 1000;
                          const remaining = Math.max(0, dot.lifetime - elapsed);
                          timerInfo = `\nTotal Lifetime: ${dot.lifetime.toFixed(1)}s\nRemaining Lifetime: ${remaining.toFixed(1)}s`;
                      } else {
                          timerInfo = `\nLifetime: Not yet saved`;
                      }
                      let habitatInfo = '';
                      if (dot.habitat !== null) {
                        habitatInfo = `\nHabitat: ${dot.habitat}`;
                      } else {
                        habitatInfo = `\nHabitat: Not yet saved`;
                      }
                      const color = dot.mesh.material.color;
                      const r = Math.round(color.r * 255);
                      const g = Math.round(color.g * 255);
                      const b = Math.round(color.b * 255);
                      const colorInfo = `\nColor (RGB): (${r}, ${g}, ${b})`;
                      infoBox.innerText = `Life ID: ${dotId.substring(0,8)}...\nInside Continent: ${dot.insideContinent}${timerInfo}${habitatInfo}${colorInfo}\n` + dnaInfo;
                      infoBox.style.display = "block";
                  }
              }
          } else {
              intersectedObject = null;
              infoBox.style.display = "none";
          }
        });
        extraBox.addEventListener("click", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObjects(selectableObjects.filter(obj => obj !== uranus));
          if (intersects.length > 0) {
            const dotMesh = intersects[0].object;
            const dotId = dotMesh.userData.dotId;
            const dot = dotData.find(d => d.id === dotId);
            const savedDNAEntry = savedDNAs.find(s => s.dotId === dotId);
            if (dot) {
                currentDotForDNA = dot.id;
                tempNewDot = null;
                if (dot.dnaData) {
                    initializeDNA(dot.dnaData);
                } else {
                    initializeDNA();
                }
                if (savedDNAEntry) {
                    document.getElementById('dna-name-input').value = savedDNAEntry.name;
                } else {
                    document.getElementById('dna-name-input').value = '';
                }
                document.getElementById('save-btn').style.display = 'none'; // FIX: Hide Save button for existing dots
                document.getElementById('remove-btn').style.display = 'inline-block';
                mainModal.style.display = 'flex';
                requestAnimationFrame(() => {
                    positionNucleotides();
                    drawConnectors();
                });
            }
          }
        });

        // --- START: MODIFIED DBLCLICK LOGIC ---
        extraBox.addEventListener("dblclick", function(event) {
          const rect = extraBox.getBoundingClientRect();
          mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          mouse.y = - ((event.clientY - rect.top) / rect.height) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(uranus);
          if (intersects.length > 0) {
            const point = intersects[0].point;
            const localPoint = uranus.worldToLocal(point.clone());
            const r = localPoint.length();
            const lat = 90 - THREE.MathUtils.radToDeg(Math.acos(localPoint.y / r));
            const lon = THREE.MathUtils.radToDeg(Math.atan2(localPoint.z, localPoint.x));
            let insideContinent = false;
            let continentIndex = null;
            for (let i = 0; i < continents.length; i++) {
              const continent = continents[i];
              const lats = continent.latLonCoordinates.map(p => p.lat);
              const lons = continent.latLonCoordinates.map(p => p.lon);
              const minLat = Math.min(...lats);
              const maxLat = Math.max(...lats);
              const minLon = Math.min(...lons);
              const maxLon = Math.max(...lons);
              if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                let minDist = Infinity;
                let closestPoint = null;
                for (const p of continent.latLonCoordinates) {
                  const dLat = p.lat - lat;
                  const dLon = p.lon - lon;
                  const dist = dLat * dLat + dLon * dLon;
                  if (dist < minDist) {
                    minDist = dist;
                    closestPoint = p;
                  }
                }
                if (closestPoint && closestPoint.isLand) {
                  insideContinent = true;
                  continentIndex = i;
                  break;
                }
              }
            }
            // START OF DNA GENERATION FOR NEW DOT (TEMPORARY)
            const newDnaData = [];
            const bases = ['A', 'T', 'C', 'G'];
            const complement = { 'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C' };
            const basesToSet = [];
            if (insideContinent) {
                // Set first 12 bases to 'C' for red color
                for (let i = 0; i < 12; i++) {
                    basesToSet.push('C');
                }
            } else {
                // Set first 12 bases for brown color (8C, 3A, 1G)
                const brownBases = ['C', 'C', 'C', 'C', 'C', 'C', 'C', 'C', 'A', 'A', 'A', 'G'];
                // Shuffle the array to randomize the order
                for (let i = brownBases.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [brownBases[i], brownBases[j]] = [brownBases[j], brownBases[i]];
                }
                for (let i = 0; i < 12; i++) {
                    basesToSet.push(brownBases[i]);
                }
            }

            // Generate the rest of the DNA string
            for (let i = 0; i < basePairsCount; i++) {
                let base;
                if (i < 12) {
                    base = basesToSet[i];
                } else {
                    base = bases[Math.floor(Math.random() * 4)];
                }
                newDnaData.push([base, complement[base]]);
            }
            // END OF DNA GENERATION

            // Set habitat based on location
            if (insideContinent) {
              newDnaData[13][0] = 'A';
              newDnaData[13][1] = 'T';
            } else {
              newDnaData[13][0] = 'T';
              newDnaData[13][1] = 'A';
            }

            // **INSTEAD OF CALLING createDot, WE STORE TEMPORARY DATA**
            tempNewDot = {
                position: localPoint,
                insideContinent: insideContinent,
                continentIndex: continentIndex,
                dnaData: newDnaData,
                lifetime: calculateLifetimeFromDNA(newDnaData),
                habitat: getHabitatFromDNA(newDnaData),
                id: THREE.MathUtils.generateUUID() // Use a temp ID
            };
            currentDotForDNA = tempNewDot.id;

            // Open Modal and display generated DNA
            initializeDNA(newDnaData);
            document.getElementById('dna-name-input').value = '';
            document.getElementById('save-btn').style.display = 'inline-block';
            document.getElementById('remove-btn').style.display = 'none';
            mainModal.style.display = 'flex';

            let habitatText = insideContinent ? 'in-land' : 'off-land';
            infoBox.innerText = `Dot added at\nLat: ${lat.toFixed(2)}°, Lon: ${lon.toFixed(2)}°\nDefault Habitat: ${habitatText}` +
              (insideContinent ? ` (Index: ${continentIndex})` : '');
            infoBox.style.display = "block";
             requestAnimationFrame(() => {
                positionNucleotides();
                drawConnectors();
            });
          } else {
            infoBox.style.display = "none";
          }
        });
        // --- END: MODIFIED DBLCLICK LOGIC ---

        const ringGeometry = new THREE.RingGeometry(4, 6, 128);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0xaaaaaa,
          side: THREE.DoubleSide,
          transparent: true,
          opacity: 0.4
        });
        ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2 + 0.5;
        ring.rotation.z = 0.5;
        scene.add(ring);
        const ringParticleCount = 35000;
        const ringParticlePositions = [];
        const ringParticleColors = [];
        const colors = [
          new THREE.Color(0xff0000),
          new THREE.Color(0xffff00),
          new THREE.Color(0x00ff00),
          new THREE.Color(0x8b4513)
        ];
        function getGradientColor(t) {
          const segment = t * (colors.length);
          const index1 = Math.floor(segment) % colors.length;
          const index2 = (index1 + 1) % colors.length;
          const localT = segment - Math.floor(segment);
          return colors[index1].clone().lerp(colors[index2], localT);
        }
        for (let i = 0; i < ringParticleCount; i++) {
          const angle = (i / ringParticleCount) * 2 * Math.PI;
          const radius = THREE.MathUtils.lerp(4.1, 5.9, Math.random());
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;
          const z = (Math.random() - 0.5) * 0.05;
          ringParticlePositions.push(x, y, z);
          const color = getGradientColor(i / ringParticleCount);
          ringParticleColors.push(color.r, color.g, color.b);
        }
        const ringParticleGeometry = new THREE.BufferGeometry();
        ringParticleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ringParticlePositions, 3));
        ringParticleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(ringParticleColors, 3));
        const starTexture = (() => {
          const size = 64;
          const canvas = document.createElement('canvas');
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
          gradient.addColorStop(0, 'rgba(255,255,255,1)');
          gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
          gradient.addColorStop(0.4, 'rgba(255,255,255,0.4)');
          gradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, size, size);
          return new THREE.CanvasTexture(canvas);
        })();
        const ringParticleMaterial = new THREE.PointsMaterial({
          size: 0.15,
          map: starTexture,
          vertexColors: true,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending,
          opacity: 0.25,
          depthWrite: false,
        });
        ringParticles = new THREE.Points(ringParticleGeometry, ringParticleMaterial);
        ringParticles.rotation.x = Math.PI / 2 + 0.5;
        ringParticles.rotation.z = 0.5;
        scene.add(ringParticles);
        const starCount = 20000;
        const starVertices = [];
        const flashVertices = [];
        for (let i = 0; i < starCount; i++) {
          const x = (Math.random() - 0.5) * 2000;
          const y = (Math.random() - 0.5) * 2000;
          const z = (Math.random() - 0.5) * 2000;
          if (Math.random() < 0.1) {
            flashVertices.push(x, y, z);
          } else {
            starVertices.push(x, y, z);
          }
        }
        const starsGeometry = new THREE.BufferGeometry();
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starsMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 1.8,
          map: starTexture,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);
        const flashingGeometry = new THREE.BufferGeometry();
        flashingGeometry.setAttribute('position', new THREE.Float32BufferAttribute(flashVertices, 3));
        const flashingMaterial = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 4.5,
          map: starTexture,
          alphaTest: 0.01,
          transparent: true,
          blending: THREE.AdditiveBlending,
          opacity: 1
        });
        flashingStars = new THREE.Points(flashingGeometry, flashingMaterial);
        scene.add(flashingStars);
        let time = 0;
        function isPointInContinent(point, continent) {
            const tempVec = new THREE.Vector3().copy(point).normalize();
            const lat = 90 - THREE.MathUtils.radToDeg(Math.acos(tempVec.y));
            const lon = THREE.MathUtils.radToDeg(Math.atan2(tempVec.z, tempVec.x));
            const lats = continent.latLonCoordinates.map(p => p.lat);
            const lons = continent.latLonCoordinates.map(p => p.lon);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);
            if (lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon) {
                let minDist = Infinity;
                let closestPoint = null;
                for (const p of continent.latLonCoordinates) {
                    const dLat = p.lat - lat;
                    const dLon = p.lon - lon;
                    const dist = dLat * dLat + dLon * dLon;
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = p;
                    }
                }
                return closestPoint && closestPoint.isLand;
            }
            return false;
        }

function createChildDot(dotA, dotB) {
    const now = Date.now();
    const HABITAT_COOLDOWNS = {
        'in-land': 25000, // Example: 20 seconds for in-land
        'off-land': 13000, // Example: 10 seconds for off-land
        'both': 17000, // Example: 15 seconds for both
        'None': 0 // Should not be needed, but safe to include
    };


    if (dotA.cooldownUntil < now && dotB.cooldownUntil < now) {

        // Habitat Inheritance
        const habitatA = dotA.habitat;
        const habitatB = dotB.habitat;
        let newHabitat;
        const rand = Math.random();

        const getHabitat = (options) => {
            let cumulative = 0;
            for (const [habitat, chance] of Object.entries(options)) {
                cumulative += chance;
                if (rand < cumulative) {
                    return habitat;
                }
            }
            return 'None';
        };

        if (habitatA === 'in-land' && habitatB === 'in-land') {
            newHabitat = getHabitat({ 'in-land': 0.95, 'None': 0.05 });
        } else if (habitatA === 'off-land' && habitatB === 'off-land') {
            newHabitat = getHabitat({ 'off-land': 0.95, 'None': 0.05 });
        } else if ((habitatA === 'in-land' && habitatB === 'both') || (habitatA === 'both' && habitatB === 'in-land')) {
            newHabitat = getHabitat({ 'both': 0.55, 'in-land': 0.35, 'off-land': 0.05, 'None': 0.05 });
        } else if ((habitatA === 'off-land' && habitatB === 'both') || (habitatA === 'both' && habitatB === 'off-land')) {
            newHabitat = getHabitat({ 'both': 0.55, 'off-land': 0.35, 'in-land': 0.05, 'None': 0.05 });
        } else if (habitatA === 'both' && habitatB === 'both') {
            newHabitat = getHabitat({ 'both': 0.25, 'in-land': 0.25, 'off-land': 0.25, 'None': 0.25 });
        } else { // Covers inland + off-land, or any other combination
            newHabitat = getHabitat({ 'both': 0.25, 'in-land': 0.25, 'off-land': 0.25, 'None': 0.25 });
        }

        // New check: If habitat is None, do not create the dot.
        if (newHabitat === 'None') {
            return;
        }

        // Color Inheritance with Noise
        const colorA = dotA.mesh.material.color;
        const colorB = dotB.mesh.material.color;
        const newR = (colorA.r + colorB.r) / 2;
        const newG = (colorA.g + colorB.g) / 2;
        const newB = (colorA.b + colorB.b) / 2;
        const noiseFactor = 0.2;
        const noisyR = THREE.MathUtils.clamp(newR + (Math.random() * 2 - 1) * newR * noiseFactor, 0, 1);
        const noisyG = THREE.MathUtils.clamp(newG + (Math.random() * 2 - 1) * newG * noiseFactor, 0, 1);
        const noisyB = THREE.MathUtils.clamp(newB + (Math.random() * 2 - 1) * newB * noiseFactor, 0, 1);
        const newColor = new THREE.Color(noisyR, noisyG, noisyB);

        // Lifetime Inheritance
        const maxParentLifetime = Math.max(dotA.lifetime || 0, dotB.lifetime || 0);
        const maxLifetimeWithBonus = maxParentLifetime * 1.1;
        const newLifetime = Math.random() * (maxLifetimeWithBonus - 1) + 1;

        const newPosition = dotA.mesh.position.clone().add(dotB.mesh.position).divideScalar(2);

        // --- START NEW CODE ---
        const bases = ['A', 'T', 'C', 'G'];
        const complement = { 'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C' };

        // Function to convert lifetime to bases (15-18)
        function generateBasesFromLifetime(lifetime) {
            const bitMapReverse = { '00': 'A', '01': 'T', '10': 'C', '11': 'G' };
            const lifetimeValue = Math.round(lifetime) - 1;
            const binaryString = lifetimeValue.toString(2).padStart(8, '0');
            const bases = [];
            for (let i = 0; i < binaryString.length; i += 2) {
                bases.push(bitMapReverse[binaryString.substring(i, i + 2)]);
            }
            return bases;
        }

        const newDnaData = [];
        const basePairsCount = 19;

        // Generate bases for color (0-11)
        const totalColorCount = noisyR + noisyG + noisyB;
        let numA = Math.round((noisyG / totalColorCount) * 12);
        let numC = Math.round((noisyR / totalColorCount) * 12);
        let numG = Math.round((noisyB / totalColorCount) * 12);

        const colorBases = [];
        for (let i = 0; i < numA; i++) colorBases.push('A');
        for (let i = 0; i < numC; i++) colorBases.push('C');
        for (let i = 0; i < numG; i++) colorBases.push('G');

        while (colorBases.length < 12) {
            colorBases.push('T'); // Fill remaining spots with wild-card T
        }

        // Shuffle the color bases to randomize their order
        for (let i = colorBases.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [colorBases[i], colorBases[j]] = [colorBases[j], colorBases[i]];
        }

        for (let i = 0; i < 12; i++) {
            const base = colorBases[i];
            newDnaData.push([base, complement[base]]);
        }

        // Placeholder for base pair 12
        const randomBase12 = bases[Math.floor(Math.random() * 4)];
        newDnaData.push([randomBase12, complement[randomBase12]]);

        // Set base pair 13 for habitat
        let habitatBase;
        if (newHabitat === 'in-land') {
            habitatBase = 'A';
        } else if (newHabitat === 'off-land') {
            habitatBase = 'T';
        } else if (newHabitat === 'both') {
            habitatBase = 'C';
        }
        newDnaData.push([habitatBase, complement[habitatBase]]);

        // Placeholder for base pair 14
        const randomBase14 = bases[Math.floor(Math.random() * 4)];
        newDnaData.push([randomBase14, complement[randomBase14]]);

        // Generate bases for lifetime (15-18)
        const lifetimeBases = generateBasesFromLifetime(newLifetime);
        for (let i = 0; i < lifetimeBases.length; i++) {
            const base = lifetimeBases[i];
            newDnaData.push([base, complement[base]]);
        }

        // --- END NEW CODE ---

        // Use the existing createDot function to instantiate the new dot
        const newDotData = createDot(
            newPosition,
            dotA.insideContinent || dotB.insideContinent,
            dotA.continentIndex || dotB.continentIndex,
            newDnaData
        );

        // Apply inherited attributes
        newDotData.mesh.material.color.set(newColor);
        newDotData.lifetime = newLifetime;
        newDotData.creationTime = now;
        newDotData.habitat = newHabitat;

        const getCooldown = (habitat) => HABITAT_COOLDOWNS[habitat] || 15000; // Use a default if something goes wrong
        dotA.cooldownUntil = now + getCooldown(dotA.habitat);
        dotB.cooldownUntil = now + getCooldown(dotB.habitat);
        newDotData.cooldownUntil = now + getCooldown(newHabitat);
    }
}

function animate() {
          requestAnimationFrame(animate);
          time += 0.02;
          if (uranus) uranus.rotation.y += 0.001;
          if (ring) ring.rotation.z += 0.0005;
          if (ringParticles) ringParticles.rotation.z += 0.0007;
          if (flashingMaterial) flashingMaterial.opacity = 0.5 + 0.5 * Math.sin(time * 2);
          const now = Date.now();
          const twoRadiiSquared = (dotRadius * 2) * (dotRadius * 2);
          let expiredDotIds = new Set();

          // --- NEW HELPER FUNCTION TO CHECK ALL CONTINENTS ---
          function getNewContinentState(position) {
              for (let i = 0; i < continents.length; i++) {
                  if (isPointInContinent(position, continents[i])) {
                      // Found the continent the dot is currently on
                      return { isLand: true, index: i };
                  }
              }
              // Not on any continent (ocean)
              return { isLand: false, index: -1 };
          }
          // --- END NEW HELPER FUNCTION ---

          dotData = dotData.filter(dot => {
              if (dot.lifetime !== null) {
                const elapsed = (now - dot.creationTime) / 1000;
                if (dot.lifetime > 0 && elapsed > dot.lifetime) {
                    uranus.remove(dot.mesh);
                    selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== dot.id);
                    expiredDotIds.add(dot.id);
                    return false;
                }
              }
              let newPosition = dot.mesh.position.clone();
              const vibration = new THREE.Vector3(
                  (Math.random() - 0.5),
                  (Math.random() - 0.5),
                  (Math.random() - 0.5)
              ).normalize().multiplyScalar(dotVibrationSpeed);
              newPosition.add(vibration);
              newPosition.normalize().multiplyScalar(planetRadius + 0.02);

              // --- START OF MODIFIED MOVEMENT LOGIC ---

              // Find the state of the new position
              const newState = getNewContinentState(newPosition);

              if (dot.habitat === 'in-land') {
                  if (newState.isLand) {
                      // Case 1: Dot moves to or stays on land (could be a new continent). Always allowed.
                      dot.mesh.position.copy(newPosition);
                      dot.position.copy(newPosition);
                      dot.insideContinent = true;
                      dot.continentIndex = newState.index; // Update to the new continent index
                  } else {
                      // Case 2: Dot attempts to move to the ocean. Apply 95% snap-back rule.
                      if (Math.random() >= 0.95) { // 5% chance to allow movement off-land
                          // Move allowed. State updated to 'ocean'.
                          dot.mesh.position.copy(newPosition);
                          dot.position.copy(newPosition);
                          dot.insideContinent = false;
                          dot.continentIndex = -1;
                      }
                      // else (95% chance): Snap-back. Position remains the old land position.
                  }
              } else {
                  // Unconditional movement for all other habitats ('off-land', 'both', or undefined)
                  dot.mesh.position.copy(newPosition);
                  dot.position.copy(newPosition); // Keep dotData object synced
                  // For these habitats, we still check the *new* state to keep the metadata correct.
                  dot.insideContinent = newState.isLand;
                  dot.continentIndex = newState.index;
              }

              // --- END OF MODIFIED MOVEMENT LOGIC ---

              return true;
          });
          if (expiredDotIds.size > 0) {
              savedDNAs = savedDNAs.filter(dna => !expiredDotIds.has(dna.dotId));
              updateSavedList();
              // Update legend after dots die
              updateLegend();
          }
          for (let i = 0; i < dotData.length; i++) {
              for (let j = i + 1; j < dotData.length; j++) {
                  const dotA = dotData[i];
                  const dotB = dotData[j];
                  const distanceSquared = dotA.mesh.position.distanceToSquared(dotB.mesh.position);
                  if (distanceSquared < twoRadiiSquared) {
                      if (dotA.cooldownUntil < now && dotB.cooldownUntil < now) {
                      createChildDot(dotA, dotB);
                      }
                  }
              }
          }

          // NEW: Update legend at the end of the frame
          updateLegend();

          if (controls) controls.update();
          if (renderer) renderer.render(scene, camera);
        }
        animate();
      });
      threeJSInitialized = true;
    }
    const speedSlider = document.getElementById('dot-speed-slider');
    if (speedSlider) {
        dotVibrationSpeed = parseFloat(speedSlider.value);
        speedSlider.addEventListener('input', (event) => {
            dotVibrationSpeed = parseFloat(event.target.value);
        });
    }
    const container = document.getElementById('dna-container');
    const basePairsCount = 19;
    const bases = ['A', 'T', 'C', 'G'];
    const complement = { 'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C' };
    const spacingX = 60;
    const twists = 3;
    const topNucleotides = [];
    const bottomNucleotides = [];
    const indexNumbers = [];
    let currentDNA = [];
    let loadedIndex = null;
    const topRow = document.createElement('div');
    topRow.className = 'strand-row';
    container.appendChild(topRow);
    const bottomRow = document.createElement('div');
    bottomRow.className = 'strand-row';
    container.appendChild(bottomRow);
    topRow.style.top = '100px';
    topRow.style.left = '20px';
    bottomRow.style.top = '250px';
    bottomRow.style.left = '20px';
    const indexRow = document.createElement('div');
    indexRow.id = 'index-row';
    container.appendChild(indexRow);
    function initializeDNA(dnaData = null) {
        topRow.innerHTML = '';
        bottomRow.innerHTML = '';
        indexRow.innerHTML = '';
        topNucleotides.length = 0;
        bottomNucleotides.length = 0;
        indexNumbers.length = 0;
        for (let i = 0; i < basePairsCount; i++) {
            const base = dnaData ? dnaData[i][0] : bases[Math.floor(Math.random() * 4)];
            const comp = complement[base];
            const topNuc = document.createElement('div');
            topNuc.className = `nucleotide ${base}`;
            topNuc.textContent = base;
            topNuc.dataset.base = base;
            topRow.appendChild(topNuc);
            topNucleotides.push(topNuc);
            const bottomNuc = document.createElement('div');
            bottomNuc.className = `nucleotide ${comp}`;
            bottomNuc.textContent = comp;
            bottomNuc.dataset.base = comp;
            bottomRow.appendChild(bottomNuc);
            bottomNucleotides.push(bottomNuc);
            const indexDiv = document.createElement('div');
            indexDiv.className = 'index-number';
            indexDiv.textContent = i;
            indexRow.appendChild(indexDiv);
            indexNumbers.push(indexDiv);
            topNuc.addEventListener('click', () => {
                let currentBase = topNuc.dataset.base;
                let newBase = bases[(bases.indexOf(currentBase) + 1) % 4];
                let newComp = complement[newBase];
                topNuc.dataset.base = newBase;
                topNuc.textContent = newBase;
                topNuc.className = 'nucleotide ' + newBase;
                bottomNuc.dataset.base = newComp;
                bottomNuc.textContent = newComp;
                bottomNuc.className = 'nucleotide ' + newComp;
                drawConnectors();
            });
        }
        positionNucleotides();
        positionIndexes();
        drawConnectors();
    }
    function positionNucleotides() {
        if (topNucleotides.length === 0) return;
        for (let i = 0; i < basePairsCount; i++) {
            const x = i * spacingX;
            const yOffsetTop = 40 * Math.sin((i / basePairsCount) * twists * 2 * Math.PI);
            const yOffsetBottom = 40 * Math.sin((i / basePairsCount) * twists * 2 * Math.PI + Math.PI);
            topNucleotides[i].style.position = 'absolute';
            topNucleotides[i].style.left = `${x}px`;
            topNucleotides[i].style.top = `${yOffsetTop}px`;
            bottomNucleotides[i].style.position = 'absolute';
            bottomNucleotides[i].style.left = `${x}px`;
            bottomNucleotides[i].style.top = `${yOffsetBottom}px`;
        }
    }
    function positionIndexes() {
      if (indexNumbers.length === 0) return;
      for (let i = 0; i < basePairsCount; i++) {
        const x = i * spacingX;
        indexNumbers[i].style.position = 'absolute';
        indexNumbers[i].style.left = `${x}px`;
      }
    }
    function drawConnectors() {
        if (topNucleotides.length === 0) return;
        const oldConnectors = container.querySelectorAll('.vertical-connector');
        oldConnectors.forEach(line => line.remove());
        for (let i = 0; i < basePairsCount; i++) {
            const topNuc = topNucleotides[i];
            const bottomNuc = bottomNucleotides[i];
            const topRect = topNuc.getBoundingClientRect();
            const bottomRect = bottomNuc.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const x = topRect.left - containerRect.left + topRect.width / 2;
            const yStart = topRect.top - containerRect.top + topRect.height;
            const yEnd = bottomRect.top - containerRect.top;
            const height = yEnd - yStart;
            const line = document.createElement('div');
            line.className = 'vertical-connector';
            line.style.left = `${x}px`;
            line.style.top = `${yStart}px`;
            line.style.height = `${height}px`;
            container.appendChild(line);
        }
    }
    function getCurrentDNA() {
        return topNucleotides.map((top, i) => [top.dataset.base, bottomNucleotides[i].dataset.base]);
    }
    function calculateLifetimeFromDNA(dna) {
        const bitMap = {
            'A': '00',
            'T': '01',
            'C': '10',
            'G': '11'
        };
        const basesToRead = [dna[15][0], dna[16][0], dna[17][0], dna[18][0]];
        const binaryString = basesToRead.map(base => bitMap[base]).join('');
        const lifetime = parseInt(binaryString, 2);
        return lifetime + 1;
    }
    function getHabitatFromDNA(dna) {
        const base = dna[13][0];
        if (base === 'A') {
            return 'in-land';
        } else if (base === 'T') {
            return 'off-land';
        } else if (base === 'C') {
            return 'both';
        } else if (base === 'G') {
            return 'None';
        }
        return 'Unknown';
    }
    const savedList = document.getElementById('saved-list');
    const mainModal = document.getElementById('modal-overlay');
    const explainBtn = document.getElementById('explain-btn');
    const explanationModal = document.getElementById('explanation-modal-overlay');
    const closeExplanationBtn = document.getElementById('close-explanation-btn');
    const closeBtn = document.getElementById('close-btn');
    const saveBtn = document.getElementById('save-btn');
    const removeBtn = document.getElementById('remove-btn');
    let unnamedCounter = 1;
    let unnamedPlanetCounter = 1;

    explainBtn.addEventListener('click', () => {
        explanationModal.style.display = 'flex';
    });
    closeExplanationBtn.addEventListener('click', () => {
        explanationModal.style.display = 'none';
    });

    // --- START: MODIFIED CLOSE BUTTON LOGIC (No longer removes mesh since it's not created on dblclick) ---
    function closeDnaModal() {
        // Only clear temporary state
        currentDotForDNA = null;
        tempNewDot = null;
        loadedIndex = null;
        mainModal.style.display = 'none';
        document.getElementById('dna-name-input').value = '';
    }

    closeBtn.addEventListener('click', closeDnaModal);
    // --- END: MODIFIED CLOSE BUTTON LOGIC ---

    // --- START: MODIFIED SAVE BUTTON LOGIC (Creates dot if tempNewDot exists) ---
    saveBtn.addEventListener('click', () => {
        const nameField = document.getElementById('dna-name-input');
        let name = nameField.value.trim();
        const dna = getCurrentDNA();
        const lifetime = calculateLifetimeFromDNA(dna);
        const habitat = getHabitatFromDNA(dna);

        let shouldClose = true;

        if (habitat === 'None') {
            // If habitat is 'None', we discard the dot, whether it was temp or an existing dot being mutated to 'None'
            if (tempNewDot) {
                // If it was a temp dot, we just discard the data. No mesh to remove.
            } else if (currentDotForDNA !== null) {
                // If it was an existing dot, remove it from the scene and data
                const dotToRemove = dotData.find(d => d.id === currentDotForDNA);
                if (dotToRemove) {
                    uranus.remove(dotToRemove.mesh);
                    dotData = dotData.filter(d => d.id !== currentDotForDNA);
                    selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== currentDotForDNA);
                }
                const savedIndex = savedDNAs.findIndex(s => s.dotId === currentDotForDNA);
                if (savedIndex !== -1) {
                    savedDNAs.splice(savedIndex, 1);
                }
            }
        } else {
            // If habitat is viable, proceed to create/update
            let dotToUpdate = null;
            let dotId = null;

            if (tempNewDot) {
                // CASE 1: NEW DOT - Create the 3D mesh and add it to the scene and dotData NOW.
                const newDotData = createDot(
                    tempNewDot.position,
                    tempNewDot.insideContinent,
                    tempNewDot.continentIndex,
                    dna // Use the DNA from the modal
                );
                // Update the new dot with final calculated properties
                newDotData.lifetime = lifetime;
                newDotData.creationTime = Date.now();
                newDotData.habitat = habitat;

                dotId = newDotData.id;
                dotToUpdate = newDotData; // dotToUpdate is now the real dot object

            } else if (currentDotForDNA !== null) {
                // CASE 2: EXISTING DOT - Find the existing dot and update its properties.
                dotToUpdate = dotData.find(d => d.id === currentDotForDNA);
                if (dotToUpdate) {
                    dotToUpdate.dnaData = dna;
                    dotToUpdate.lifetime = lifetime;
                    dotToUpdate.creationTime = Date.now();
                    dotToUpdate.habitat = habitat;
                    dotId = dotToUpdate.id;
                }
            }

            if (dotToUpdate) {
                // Color update logic
                let aCount = 0;
                let cCount = 0;
                let gCount = 0;
                for (let i = 0; i < Math.min(12, dna.length); i++) {
                    const base = dna[i][0];
                    switch (base) {
                        case 'A': aCount++; break;
                        case 'C': cCount++; break;
                        case 'G': gCount++; break;
                        case 'T':
                            const randomBase = ['A', 'C', 'G'][Math.floor(Math.random() * 3)];
                            if (randomBase === 'A') aCount++;
                            else if (randomBase === 'C') cCount++;
                            else gCount++;
                            break;
                    }
                }
                const totalCount = aCount + cCount + gCount;
                let r = 0, g = 0, b = 0;
                if (totalCount > 0) {
                    r = cCount / totalCount;
                    g = aCount / totalCount;
                    b = gCount / totalCount;
                }
                dotToUpdate.mesh.material.color.setRGB(r, g, b);

                if (!name) {
                    if (dotId) {
                        name = `Planet DNA ${unnamedPlanetCounter++}`;
                    } else {
                        name = `Undefined DNA ${unnamedCounter++}`;
                    }
                }
                // Save/Update DNA to saved list
                const savedIndex = savedDNAs.findIndex(s => s.dotId === dotId);
                if (savedIndex !== -1) {
                    savedDNAs[savedIndex] = { name, data: dna, dotId };
                } else {
                    savedDNAs.push({ name, data: dna, dotId });
                }
                updateSavedList();
            }
        }

        // Reset state and close modal
        currentDotForDNA = null;
        loadedIndex = null;
        tempNewDot = null; // IMPORTANT: Clear temporary data
        mainModal.style.display = 'none';
        document.getElementById('dna-name-input').value = '';
        updateLegend();
    });
    // --- END: MODIFIED SAVE BUTTON LOGIC ---

    removeBtn.addEventListener('click', () => {
        if (currentDotForDNA !== null) {
            const dotToRemove = dotData.find(d => d.id === currentDotForDNA);
            if (dotToRemove) {
                uranus.remove(dotToRemove.mesh);
                dotData = dotData.filter(d => d.id !== currentDotForDNA);
                selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== currentDotForDNA);
            }
            const savedIndex = savedDNAs.findIndex(s => s.dotId === currentDotForDNA);
            if (savedIndex !== -1) {
                savedDNAs.splice(savedIndex, 1);
            }
        }
        currentDotForDNA = null;
        updateSavedList();
        // Update legend after removal
        updateLegend();
        mainModal.style.display = 'none';
    });
    function addToSavedList(index) {
        const dnaObj = savedDNAs[index];
        const item = document.createElement('div');
        item.className = 'saved-item';
        item.dataset.index = index;
        const nameSpan = document.createElement('span');
        nameSpan.textContent = dnaObj.name;
        item.appendChild(nameSpan);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'x';
        item.appendChild(deleteBtn);
        let clickTimer = null;
        let dblClicked = false;
        item.addEventListener('dblclick', (event) => {
            event.stopPropagation();
            dblClicked = true;
            clearTimeout(clickTimer);
            const input = document.createElement('input');
            input.type = 'text';
            input.value = dnaObj.name;
            input.style.width = 'calc(100% - 20px)';
            input.style.border = 'none';
            input.style.background = '#333';
            input.style.color = 'white';
            input.style.fontFamily = 'monospace';
            item.replaceChild(input, nameSpan);
            input.focus();
            input.select();
            const saveName = () => {
                const newName = input.value.trim();
                savedDNAs[index].name = newName || `Undefined DNA ${unnamedCounter++}`;
                nameSpan.textContent = savedDNAs[index].name;
                item.replaceChild(nameSpan, input);
            };
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    saveName();
                    input.blur();
                } else if (e.key === 'Escape') {
                    nameSpan.textContent = savedDNAs[index].name;
                    item.replaceChild(nameSpan, input);
                    input.blur();
                }
            });
            input.addEventListener('blur', saveName);
        });
        item.addEventListener('click', () => {
            dblClicked = false;
            clickTimer = setTimeout(() => {
                if (!dblClicked) {
                    currentDotForDNA = savedDNAs[index].dotId || null;
                    tempNewDot = null;
                    loadedIndex = index;
                    initializeDNA(savedDNAs[index].data);
                    document.getElementById('dna-name-input').value = savedDNAs[index].name;
                    saveBtn.style.display = 'none';
                    removeBtn.style.display = 'inline-block';
                    mainModal.style.display = 'flex';
                    requestAnimationFrame(() => {
                        positionNucleotides();
                        drawConnectors();
                    });
                }
            }, 250);
        });
        deleteBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const dotId = savedDNAs[index].dotId;
            if (dotId) {
                const dot = dotData.find(d => d.id === dotId);
                if (dot) {
                    uranus.remove(dot.mesh);
                    dotData = dotData.filter(d => d.id !== dotId);
                    selectableObjects = selectableObjects.filter(obj => obj.userData.dotId !== dotId);
                }
            }
            savedDNAs.splice(index, 1);
            updateSavedList();
        });
        savedList.appendChild(item);
    }

    function updateSavedList() {
        savedList.innerHTML = '';
        savedDNAs.forEach((_, i) => addToSavedList(i));
    }
    window.addEventListener('resize', () => {
        positionNucleotides();
        positionIndexes();
        drawConnectors();
        if (camera && renderer && controls) {
          camera.aspect = extraBox.clientWidth / extraBox.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(extraBox.clientWidth, extraBox.clientHeight);
        }
    });
    document.addEventListener('DOMContentLoaded', () => {
      initPlanetVisualization();
      // Initial call to display 0s
      updateLegend();
    });
</script>
</body>
</html>